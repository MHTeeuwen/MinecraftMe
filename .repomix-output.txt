This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repomix on: 2025-04-02T16:12:53.134Z

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.
</notes>

<additional_info>

</additional_info>

</file_summary>

<directory_structure>
client/
  public/
    index.html
    manifest.json
  src/
    components/
      __tests__/
        ImageUpload.test.js
      ImageUpload.js
    services/
      __tests__/
        imageService.test.js
        openaiService.test.js
      imageService.js
      openaiService.js
    App.js
    App.test.js
    index.css
    index.js
    minecraft.css
  package.json
docs/
  cursor-rules.md
  DevelopmentGuidelines.md
  overview.md
  TechStack.md
minecraftme/
  examples/
server/
  __tests__/
    convert.test.js
    openai.test.js
  middleware/
    validation.js
  routes/
    convert.js
    test.js
  services/
    openai.js
  temp/
  utils/
    errors.js
  package.json
  server.js
  test-direct-api.js
  test-image-upload.js
  test-openai.js
package.json
test-image-upload.js
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="client/public/index.html">
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <link rel="icon" href="%PUBLIC_URL%/favicon.ico" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="theme-color" content="#000000" />
    <meta
      name="description"
      content="Minecraft Me - Convert your photos to Minecraft style"
    />
    <link rel="apple-touch-icon" href="%PUBLIC_URL%/logo192.png" />
    <link rel="manifest" href="%PUBLIC_URL%/manifest.json" />
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
    <title>Minecraft Me</title>
  </head>
  <body>
    <noscript>You need to enable JavaScript to run this app.</noscript>
    <div id="root"></div>
  </body>
</html>
</file>

<file path="client/public/manifest.json">
{
  "short_name": "Minecraft Me",
  "name": "Minecraft Me - Photo Converter",
  "icons": [
    {
      "src": "favicon.ico",
      "sizes": "64x64 32x32 24x24 16x16",
      "type": "image/x-icon"
    },
    {
      "src": "logo192.png",
      "type": "image/png",
      "sizes": "192x192"
    },
    {
      "src": "logo512.png",
      "type": "image/png",
      "sizes": "512x512"
    }
  ],
  "start_url": ".",
  "display": "standalone",
  "theme_color": "#000000",
  "background_color": "#ffffff"
}
</file>

<file path="client/src/components/__tests__/ImageUpload.test.js">
import React from 'react';
import { render, screen, fireEvent } from '@testing-library/react';
import ImageUpload from '../ImageUpload';
describe('ImageUpload', () => {
  const mockOnImageSelect = jest.fn();
  beforeEach(() => {
    mockOnImageSelect.mockClear();
  });
  test('renders upload area with correct text', () => {
    render(<ImageUpload onImageSelect={mockOnImageSelect} />);
    expect(screen.getByText(/Drop your photo here/i)).toBeInTheDocument();
    expect(screen.getByText(/Choose a File/i)).toBeInTheDocument();
  });
  test('handles file selection', () => {
    render(<ImageUpload onImageSelect={mockOnImageSelect} />);
    const file = new File(['dummy content'], 'test.png', { type: 'image/png' });
    const input = screen.getByAcceptingUpload();
    fireEvent.change(input, { target: { files: [file] } });
    expect(mockOnImageSelect).toHaveBeenCalledWith(file);
  });
  test('shows error for invalid file type', () => {
    render(<ImageUpload onImageSelect={mockOnImageSelect} />);
    const file = new File(['dummy content'], 'test.txt', { type: 'text/plain' });
    const input = screen.getByAcceptingUpload();
    fireEvent.change(input, { target: { files: [file] } });
    expect(screen.getByText(/Please upload an image file/i)).toBeInTheDocument();
    expect(mockOnImageSelect).not.toHaveBeenCalled();
  });
  test('shows error for large files', () => {
    render(<ImageUpload onImageSelect={mockOnImageSelect} />);
    // Create a mock file larger than 5MB
    const largeFile = new File(['x'.repeat(6 * 1024 * 1024)], 'large.jpg', { type: 'image/jpeg' });
    const input = screen.getByAcceptingUpload();
    fireEvent.change(input, { target: { files: [largeFile] } });
    expect(screen.getByText(/Image must be less than 5MB/i)).toBeInTheDocument();
    expect(mockOnImageSelect).not.toHaveBeenCalled();
  });
});
</file>

<file path="client/src/components/ImageUpload.js">
import React, { useState, useRef, useEffect, useCallback } from 'react';
function ImageUpload({ onImageSelect }) {
  const [isDragging, setIsDragging] = useState(false);
  const fileInputRef = useRef(null);
  const buttonRef = useRef(null);
  const handleButtonClick = useCallback((e) => {
    if (e) {
      e.preventDefault();
      e.stopPropagation();
    }
    if (fileInputRef.current) {
      fileInputRef.current.click();
    }
  }, []);
  useEffect(() => {
    const currentButton = buttonRef.current;
    if (currentButton) {
      const clickHandler = (e) => {
        handleButtonClick(e);
      };
      currentButton.addEventListener('click', clickHandler);
      return () => {
        currentButton.removeEventListener('click', clickHandler);
      };
    }
  }, [handleButtonClick]);
  const handleFileSelect = (e) => {
    const file = e.target.files[0];
    if (file && validateFile(file)) {
      onImageSelect(file);
    }
    // Reset the file input to allow re-uploading the same file
    e.target.value = null;
  };
  const validateFile = (file) => {
    // Check file type
    if (!file.type.startsWith('image/')) {
      onImageSelect(null, 'Please upload an image file');
      return false;
    }
    // Check file size (10MB limit to account for base64 encoding overhead)
    if (file.size > 10 * 1024 * 1024) {
      onImageSelect(null, 'Image must be smaller than 10MB. Please choose a smaller image or compress it before uploading.');
      return false;
    }
    return true;
  };
  const handleDrag = (e) => {
    e.preventDefault();
    e.stopPropagation();
  };
  const handleDragIn = (e) => {
    e.preventDefault();
    e.stopPropagation();
    setIsDragging(true);
  };
  const handleDragOut = (e) => {
    e.preventDefault();
    e.stopPropagation();
    setIsDragging(false);
  };
  const handleDrop = (e) => {
    e.preventDefault();
    e.stopPropagation();
    setIsDragging(false);
    const file = e.dataTransfer.files[0];
    if (file && validateFile(file)) {
      onImageSelect(file);
    }
  };
  return (
    <div 
      style={{ marginTop: '20px' }}
      onClick={(e) => e.stopPropagation()}
    >
      <div
        className={`minecraft-box ${isDragging ? 'breaking' : ''}`}
        style={{
          padding: '40px 20px',
          backgroundColor: isDragging ? 'rgba(255,255,255,0.1)' : 'rgba(0,0,0,0.3)',
          cursor: 'pointer',
          transition: 'all 0.2s ease',
          maxWidth: '800px',
          margin: '0 auto',
          position: 'relative'
        }}
        onDragEnter={handleDragIn}
        onDragLeave={handleDragOut}
        onDragOver={handleDrag}
        onDrop={handleDrop}
      >
        <div className="minecraft-text" style={{ marginBottom: '10px' }}>
          Drop your photo here
        </div>
        <p style={{ marginBottom: '20px' }}>or</p>
        <button
          ref={buttonRef}
          className="minecraft-btn"
          onClick={handleButtonClick}
          type="button"
          style={{
            backgroundColor: '#4CAF50',
            padding: '10px 20px',
            fontSize: '16px',
            cursor: 'pointer',
            position: 'relative',
            zIndex: 10
          }}
        >
          Choose a File
        </button>
        <input
          ref={fileInputRef}
          type="file"
          accept="image/*"
          onChange={handleFileSelect}
          style={{ display: 'none' }}
          aria-label="Upload image"
        />
      </div>
    </div>
  );
}
export default ImageUpload;
</file>

<file path="client/src/services/__tests__/imageService.test.js">
import { convertToMinecraft } from '../imageService';
// Mock fetch globally
global.fetch = jest.fn();
describe('imageService', () => {
  beforeEach(() => {
    // Clear mock before each test
    fetch.mockClear();
  });
  it('successfully converts an image', async () => {
    // Mock successful response
    const mockResponse = {
      convertedImageUrl: 'http://example.com/converted.png'
    };
    fetch.mockImplementationOnce(() => 
      Promise.resolve({
        ok: true,
        json: () => Promise.resolve(mockResponse)
      })
    );
    const mockFile = new File([''], 'test.png', { type: 'image/png' });
    const result = await convertToMinecraft(mockFile);
    expect(result).toEqual(mockResponse);
    expect(fetch).toHaveBeenCalledTimes(1);
    expect(fetch).toHaveBeenCalledWith('/api/convert', expect.any(Object));
  });
  it('handles API errors', async () => {
    // Mock error response
    fetch.mockImplementationOnce(() => 
      Promise.resolve({
        ok: false,
        json: () => Promise.resolve({ message: 'API Error' })
      })
    );
    const mockFile = new File([''], 'test.png', { type: 'image/png' });
    await expect(convertToMinecraft(mockFile)).rejects.toThrow('Failed to convert image: API Error');
  });
  it('handles network errors', async () => {
    // Mock network error
    fetch.mockImplementationOnce(() => 
      Promise.reject(new Error('Network error'))
    );
    const mockFile = new File([''], 'test.png', { type: 'image/png' });
    await expect(convertToMinecraft(mockFile)).rejects.toThrow('Failed to convert image: Network error');
  });
});
</file>

<file path="client/src/services/__tests__/openaiService.test.js">
import { convertToMinecraftStyle } from '../openaiService';
// Mock fetch globally
global.fetch = jest.fn();
// Mock URL.createObjectURL
global.URL.createObjectURL = jest.fn();
describe('openaiService', () => {
  beforeEach(() => {
    // Clear mocks before each test
    fetch.mockClear();
    URL.createObjectURL.mockClear();
  });
  it('successfully converts an image to Minecraft style', async () => {
    // Mock successful response
    const mockResponse = {
      url: 'http://example.com/converted.png'
    };
    fetch.mockImplementationOnce(() => 
      Promise.resolve({
        ok: true,
        json: () => Promise.resolve(mockResponse)
      })
    );
    // Mock URL.createObjectURL
    URL.createObjectURL.mockReturnValue('blob:test-url');
    const mockFile = new File([''], 'test.png', { type: 'image/png' });
    const result = await convertToMinecraftStyle(mockFile);
    expect(result).toEqual({
      originalImage: 'blob:test-url',
      convertedImageUrl: 'http://example.com/converted.png'
    });
    expect(fetch).toHaveBeenCalledTimes(1);
    expect(fetch).toHaveBeenCalledWith('/api/convert', expect.any(Object));
  });
  it('handles API errors', async () => {
    // Mock error response
    fetch.mockImplementationOnce(() => 
      Promise.resolve({
        ok: false,
        json: () => Promise.resolve({ message: 'OpenAI API Error' })
      })
    );
    const mockFile = new File([''], 'test.png', { type: 'image/png' });
    await expect(convertToMinecraftStyle(mockFile)).rejects.toThrow('Failed to convert image: OpenAI API Error');
  });
  it('handles network errors', async () => {
    // Mock network error
    fetch.mockImplementationOnce(() => 
      Promise.reject(new Error('Network error'))
    );
    const mockFile = new File([''], 'test.png', { type: 'image/png' });
    await expect(convertToMinecraftStyle(mockFile)).rejects.toThrow('Failed to convert image: Network error');
  });
  it('handles file reading errors', async () => {
    // Create a file that will fail to read
    const mockFile = new File([''], 'test.png', { type: 'image/png' });
    // Mock FileReader to simulate an error
    const mockFileReader = {
      readAsDataURL: jest.fn(),
      onerror: null,
    };
    jest.spyOn(window, 'FileReader').mockImplementation(() => mockFileReader);
    // Simulate FileReader error
    setTimeout(() => {
      mockFileReader.onerror(new Error('File reading failed'));
    }, 0);
    await expect(convertToMinecraftStyle(mockFile)).rejects.toThrow('Failed to convert image');
  });
});
</file>

<file path="client/src/services/imageService.js">
// Handles image conversion API calls
const convertToMinecraft = async (imageFile) => {
  try {
    // Create form data for the image
    const formData = new FormData();
    formData.append('image', imageFile);
    // Make API call to your backend endpoint
    const response = await fetch('/api/convert', {
      method: 'POST',
      body: formData,
    });
    if (!response.ok) {
      const error = await response.json();
      throw new Error(error.message || 'Failed to convert image');
    }
    const result = await response.json();
    return result;
  } catch (error) {
    console.error('Image conversion failed:', error);
    throw new Error('Failed to convert image: ' + error.message);
  }
};
export { convertToMinecraft };
</file>

<file path="client/src/services/openaiService.js">
// Handles OpenAI API interactions for image conversion
const API_URL = 'http://localhost:3001';
const MINECRAFT_PROMPT = "Convert this image into Minecraft style, with 16x16 pixel blocks, using Minecraft's signature blocky textures and color palette. Maintain the original image's composition but render it in Minecraft's distinct cubic style.";
const convertImageToBase64 = (file) => {
  return new Promise((resolve, reject) => {
    const reader = new FileReader();
    reader.readAsDataURL(file);
    reader.onload = () => {
      // Remove data:image/jpeg;base64, prefix
      const base64String = reader.result.split(',')[1];
      resolve(base64String);
    };
    reader.onerror = (error) => reject(error);
  });
};
const convertToMinecraftStyle = async (imageFile) => {
  try {
    console.log('Starting conversion process for:', imageFile.name);
    // Convert image to base64
    const base64Image = await convertImageToBase64(imageFile);
    console.log('Image converted to base64');
    // Prepare the API request
    const response = await fetch(`${API_URL}/api/convert`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({
        image: base64Image,
        prompt: MINECRAFT_PROMPT,
        size: '1024x1024',
      }),
    });
    console.log('Received response:', {
      status: response.status,
      ok: response.ok,
      statusText: response.statusText
    });
    // Handle non-200 responses
    if (!response.ok) {
      const errorData = await response.json();
      console.error('API Error:', errorData);
      throw new Error(errorData.error || 'Failed to convert image');
    }
    const result = await response.json();
    console.log('Parsed response:', {
      status: result.status,
      hasUrl: !!result.url,
      status: result.status
    });
    // Validate response data
    if (result.status !== 'success' || !result.url) {
      throw new Error('Invalid response format from server');
    }
    return {
      originalImage: URL.createObjectURL(imageFile),
      convertedImageUrl: result.url,
    };
  } catch (error) {
    console.error('OpenAI conversion failed:', error);
    throw new Error('Failed to convert image: ' + error.message);
  }
};
export { convertToMinecraftStyle };
</file>

<file path="client/src/App.js">
// Main App component for Minecraft Me
import React, { useState } from 'react';
import './minecraft.css';
import ImageUpload from './components/ImageUpload';
function App() {
  const [uploadedImage, setUploadedImage] = useState(null);
  const [isConverting, setIsConverting] = useState(false);
  const [convertedImage, setConvertedImage] = useState(null);
  const [error, setError] = useState('');
  const handleImageSelect = async (file) => {
    // Validate that file is a valid File object
    if (!(file instanceof File)) {
      setError('Invalid file. Please upload a valid image.');
      setIsConverting(false);
      return;
    }
    setUploadedImage(file);
    setIsConverting(true);
    setError('');
    setConvertedImage(null); // Reset converted image
    try {
      // Convert the file to base64
      const reader = new FileReader();
      const base64Image = await new Promise((resolve) => {
        reader.onloadend = () => resolve(reader.result.split(',')[1]); // Remove "data:image/png;base64," prefix
        reader.readAsDataURL(file);
      });
      // Make API call to convert the image
      const response = await fetch('http://localhost:3001/api/convert', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          image: base64Image,
          prompt: 'Provide a concise description of the main subject in this image as a Minecraft character with blocky, pixelated features, cubic limbs, and a simplified color palette. Include specific details about their appearance, clothing, accessories, and any objects they are holding or interacting with. Do not provide instructions or steps.',
          size: '1024x1024'
        }),
      });
      const data = await response.json();
      console.log('Client received:', data);
      if (!response.ok || !data.success) {
        throw new Error(data.error || 'Failed to convert image');
      }
      setConvertedImage(data.url);
    } catch (err) {
      console.error('Conversion error:', err);
      setError('Failed to convert image. Please try again.');
    } finally {
      setIsConverting(false);
    }
  };
  // Example image pairs using actual images from examples directory
  const examplePairs = [
    {
      before: '/examples/input1.png',
      after: '/examples/output1.png'
    },
    {
      before: '/examples/input2.png',
      after: '/examples/output2.png'
    },
    {
      before: '/examples/input3.png',
      after: '/examples/output3.png'
    }
  ];
  return (
    <div className="stone-bg" style={{
      minHeight: '100vh',
      color: 'white',
      fontFamily: '-apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Arial, sans-serif'
    }}>
      {/* Hero Section */}
      <div className="grass-top" style={{
        padding: '60px 20px',
        textAlign: 'center',
        position: 'relative',
        overflow: 'hidden'
      }}>
        <h1 className="minecraft-text" style={{
          fontSize: '48px',
          marginBottom: '30px',
          color: '#FFFFFF',
          lineHeight: '1.4'
        }}>Turn Your Photos Into Minecraft Art!</h1>
        {convertedImage ? (
          <div style={{ marginBottom: '40px' }}>
            <h2 className="minecraft-text" style={{ 
              fontSize: '24px', 
              marginBottom: '20px',
              color: '#FFFFFF'
            }}>Your Minecraft Style Photo is Ready!</h2>
            <div style={{
              display: 'flex',
              justifyContent: 'center',
              gap: '40px',
              flexWrap: 'wrap',
              maxWidth: '1200px',
              margin: '0 auto'
            }}>
              <div className="minecraft-box" style={{
                padding: '20px',
                backgroundColor: 'rgba(0,0,0,0.3)'
              }}>
                <img 
                  src={uploadedImage ? URL.createObjectURL(uploadedImage) : ''} 
                  alt="Original" 
                  style={{
                    maxWidth: '100%',
                    maxHeight: '300px',
                    border: '4px solid #000'
                  }}
                />
                <p style={{ marginTop: '10px' }}>Original</p>
              </div>
              <div className="minecraft-box" style={{
                padding: '20px',
                backgroundColor: 'rgba(0,0,0,0.3)'
              }}>
                <img 
                  src={convertedImage} 
                  alt="Minecraft Style" 
                  style={{
                    maxWidth: '100%',
                    maxHeight: '300px',
                    border: '4px solid #000'
                  }}
                />
                <p style={{ marginTop: '10px' }}>Minecraft Style</p>
              </div>
            </div>
            <button
              className="minecraft-btn minecraft-text"
              onClick={() => {
                setUploadedImage(null);
                setConvertedImage(null);
                setError('');
              }}
              style={{
                backgroundColor: '#4CAF50',
                padding: '10px 20px',
                fontSize: '16px',
                marginTop: '20px'
              }}
            >
              Convert Another Photo
            </button>
          </div>
        ) : (
          <>
            <p style={{
              fontSize: '20px',
              marginBottom: '30px',
              color: '#FFFFFF',
              maxWidth: '600px',
              margin: '0 auto 30px',
              lineHeight: '1.6',
              textShadow: '1px 1px 0px rgba(0,0,0,0.5)'
            }}>Just upload your favorite photos and watch the magic happen!</p>
            {/* Image Upload Component */}
            <ImageUpload onImageSelect={handleImageSelect} />
            {isConverting && (
              <div style={{
                marginTop: '20px',
                padding: '20px',
                backgroundColor: 'rgba(0,0,0,0.3)',
                borderRadius: '4px'
              }}>
                <div className="minecraft-text breaking">Converting your photo...</div>
              </div>
            )}
            {error && (
              <div style={{
                marginTop: '20px',
                padding: '20px',
                backgroundColor: 'rgba(255,0,0,0.2)',
                borderRadius: '4px',
                color: '#ff4d4d'
              }}>
                {error}
              </div>
            )}
          </>
        )}
      </div>
      {/* Only show examples if no image is being processed */}
      {!uploadedImage && !isConverting && (
        <>
          {/* How It Works */}
          <div className="dirt-bg" style={{
            padding: '60px 20px',
            color: '#FFFFFF',
            textAlign: 'center'
          }}>
            <h2 className="minecraft-text" style={{ 
              fontSize: '36px', 
              marginBottom: '40px',
              lineHeight: '1.4'
            }}>How It Works</h2>
            <div style={{
              display: 'flex',
              justifyContent: 'center',
              gap: '40px',
              flexWrap: 'wrap',
              maxWidth: '1200px',
              margin: '0 auto'
            }}>
              <div className="minecraft-box stone-bg" style={{ 
                flex: '1', 
                minWidth: '250px', 
                maxWidth: '350px',
                padding: '20px'
              }}>
                <div className="minecraft-text" style={{ 
                  fontSize: '20px', 
                  marginBottom: '15px',
                  lineHeight: '1.4'
                }}>1. Upload Your Photo</div>
                <p style={{
                  fontSize: '16px',
                  lineHeight: '1.6',
                  textShadow: '1px 1px 0px rgba(0,0,0,0.5)'
                }}>Choose any photo you love - family pictures, vacation memories, or your favorite selfie!</p>
              </div>
              <div className="minecraft-box stone-bg" style={{ 
                flex: '1', 
                minWidth: '250px', 
                maxWidth: '350px',
                padding: '20px'
              }}>
                <div className="minecraft-text" style={{ 
                  fontSize: '20px', 
                  marginBottom: '15px',
                  lineHeight: '1.4'
                }}>2. Watch the Magic</div>
                <p style={{
                  fontSize: '16px',
                  lineHeight: '1.6',
                  textShadow: '1px 1px 0px rgba(0,0,0,0.5)'
                }}>Our special tool turns your photo into beautiful Minecraft blocks - just like in the movie!</p>
              </div>
              <div className="minecraft-box stone-bg" style={{ 
                flex: '1', 
                minWidth: '250px', 
                maxWidth: '350px',
                padding: '20px'
              }}>
                <div className="minecraft-text" style={{ 
                  fontSize: '20px', 
                  marginBottom: '15px',
                  lineHeight: '1.4'
                }}>3. Download & Share</div>
                <p style={{
                  fontSize: '16px',
                  lineHeight: '1.6',
                  textShadow: '1px 1px 0px rgba(0,0,0,0.5)'
                }}>Get your Minecraft-style picture and share it with friends and family!</p>
              </div>
            </div>
          </div>
          {/* Examples Section */}
          <div className="stone-bg" style={{
            padding: '60px 20px',
            color: '#FFFFFF',
            textAlign: 'center'
          }}>
            <h2 className="minecraft-text" style={{ 
              fontSize: '36px', 
              marginBottom: '40px',
              lineHeight: '1.4'
            }}>See the Magic!</h2>
            <div style={{
              display: 'flex',
              justifyContent: 'center',
              gap: '40px',
              flexWrap: 'wrap',
              maxWidth: '1200px',
              margin: '0 auto'
            }}>
              {examplePairs.map((pair, index) => (
                <div key={index} className="minecraft-box dirt-bg" style={{
                  flex: '1',
                  minWidth: '300px',
                  maxWidth: '350px',
                  padding: '20px'
                }}>
                  {/* Top image - Original */}
                  <div style={{
                    border: '4px solid #000',
                    marginBottom: '10px',
                    padding: '8px',
                    backgroundColor: '#5c4033',
                    height: '250px',
                    overflow: 'hidden'
                  }}>
                    <img 
                      src={pair.before}
                      alt="Original" 
                      style={{
                        display: 'block',
                        width: '100%',
                        height: '100%',
                        objectFit: 'cover',
                        objectPosition: 'center',
                        border: '2px solid #000'
                      }}
                    />
                  </div>
                  <div className="minecraft-text" style={{
                    fontSize: '20px',
                    marginBottom: '5px',
                    color: '#FFFFFF',
                    textShadow: '2px 2px 0px #000'
                  }}>Original</div>
                  <div className="minecraft-text" style={{
                    fontSize: '24px',
                    margin: '5px 0',
                    color: '#FFFFFF'
                  }}>↓</div>
                  {/* Bottom image - Minecraft Style */}
                  <div style={{
                    border: '4px solid #000',
                    marginTop: '10px',
                    padding: '8px',
                    backgroundColor: '#5c4033',
                    height: '250px',
                    overflow: 'hidden'
                  }}>
                    <img 
                      src={pair.after}
                      alt="Minecraft Style" 
                      style={{
                        display: 'block',
                        width: '100%',
                        height: '100%',
                        objectFit: 'cover',
                        objectPosition: 'center',
                        border: '2px solid #000'
                      }}
                    />
                  </div>
                  <div className="minecraft-text" style={{
                    fontSize: '20px',
                    marginTop: '5px',
                    color: '#FFFFFF',
                    textShadow: '2px 2px 0px #000'
                  }}>Minecraft Style</div>
                </div>
              ))}
            </div>
          </div>
          {/* Pricing Section */}
          <div className="grass-top" style={{
            padding: '60px 20px',
            textAlign: 'center'
          }}>
            <h2 className="minecraft-text" style={{ 
              fontSize: '36px', 
              marginBottom: '40px', 
              color: '#FFFFFF',
              lineHeight: '1.4'
            }}>Simple Pricing</h2>
            <div style={{
              display: 'flex',
              justifyContent: 'center',
              gap: '30px',
              flexWrap: 'wrap',
              maxWidth: '1200px',
              margin: '0 auto'
            }}>
              {/* Starter Pack */}
              <div className="minecraft-box stone-bg" style={{
                flex: '1',
                minWidth: '250px',
                maxWidth: '300px',
                padding: '30px'
              }}>
                <h3 className="minecraft-text" style={{ 
                  fontSize: '24px', 
                  marginBottom: '15px',
                  lineHeight: '1.4'
                }}>Starter Pack</h3>
                <div className="minecraft-text" style={{ fontSize: '36px', marginBottom: '20px' }}>$5</div>
                <p style={{
                  marginBottom: '20px',
                  fontSize: '16px',
                  lineHeight: '1.6',
                  textShadow: '1px 1px 0px rgba(0,0,0,0.5)'
                }}>10 Photos</p>
                <button className="minecraft-btn minecraft-text" style={{
                  backgroundColor: '#ff4d4d',
                  padding: '10px 20px',
                  fontSize: '16px'
                }}>Get Started</button>
              </div>
              {/* Popular Pack */}
              <div className="minecraft-box stone-bg breaking" style={{
                flex: '1',
                minWidth: '250px',
                maxWidth: '300px',
                padding: '30px',
                position: 'relative',
                transform: 'scale(1.05)'
              }}>
                <div className="minecraft-text" style={{
                  position: 'absolute',
                  top: '-12px',
                  left: '50%',
                  transform: 'translateX(-50%)',
                  backgroundColor: '#ff8c1a',
                  padding: '5px 15px',
                  fontSize: '14px',
                  border: '2px solid #000'
                }}>MOST POPULAR</div>
                <h3 className="minecraft-text" style={{ 
                  fontSize: '24px', 
                  marginBottom: '15px',
                  lineHeight: '1.4'
                }}>Value Pack</h3>
                <div className="minecraft-text" style={{ fontSize: '36px', marginBottom: '20px' }}>$10</div>
                <p style={{
                  marginBottom: '20px',
                  fontSize: '16px',
                  lineHeight: '1.6',
                  textShadow: '1px 1px 0px rgba(0,0,0,0.5)'
                }}>30 Photos</p>
                <button className="minecraft-btn minecraft-text" style={{
                  backgroundColor: '#ff8c1a',
                  padding: '10px 20px',
                  fontSize: '16px'
                }}>Best Value!</button>
              </div>
              {/* Family Pack */}
              <div className="minecraft-box stone-bg" style={{
                flex: '1',
                minWidth: '250px',
                maxWidth: '300px',
                padding: '30px'
              }}>
                <h3 className="minecraft-text" style={{ 
                  fontSize: '24px', 
                  marginBottom: '15px',
                  lineHeight: '1.4'
                }}>Family Pack</h3>
                <div className="minecraft-text" style={{ fontSize: '36px', marginBottom: '20px' }}>$15</div>
                <p style={{
                  marginBottom: '20px',
                  fontSize: '16px',
                  lineHeight: '1.6',
                  textShadow: '1px 1px 0px rgba(0,0,0,0.5)'
                }}>50 Photos</p>
                <button className="minecraft-btn minecraft-text" style={{
                  backgroundColor: '#4CAF50',
                  padding: '10px 20px',
                  fontSize: '16px'
                }}>Get Started</button>
              </div>
            </div>
            <div className="minecraft-box" style={{
              marginTop: '30px',
              padding: '15px',
              display: 'inline-block',
              backgroundColor: 'rgba(0,0,0,0.5)'
            }}>
              <p style={{
                fontSize: '16px',
                lineHeight: '1.6',
                textShadow: '1px 1px 0px rgba(0,0,0,0.5)'
              }}>🎁 Want to give this as a gift? Click any package to add a gift message!</p>
            </div>
          </div>
        </>
      )}
      {/* Footer */}
      <div className="stone-bg" style={{
        padding: '20px',
        textAlign: 'center',
        borderTop: '4px solid #000'
      }}>
        <p style={{ 
          color: '#FFFFFF',
          fontSize: '14px',
          lineHeight: '1.6',
          textShadow: '1px 1px 0px rgba(0,0,0,0.5)'
        }}>Made with ❤️ for Minecraft fans everywhere</p>
      </div>
    </div>
  );
}
export default App;
</file>

<file path="client/src/App.test.js">
// Tests for the main App component
import { render, screen } from '@testing-library/react';
import App from './App';
describe('App', () => {
  test('renders main heading', () => {
    render(<App />);
    const headingElement = screen.getByText(/Minecraft Me/i);
    expect(headingElement).toBeInTheDocument();
  });
  test('renders upload prompt', () => {
    render(<App />);
    const uploadText = screen.getByText(/Upload a photo to get started!/i);
    expect(uploadText).toBeInTheDocument();
  });
});
</file>

<file path="client/src/index.css">
* {
  margin: 0;
  padding: 0;
  box-sizing: border-box;
}
body {
  margin: 0;
  font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', 'Oxygen',
    'Ubuntu', 'Cantarell', 'Fira Sans', 'Droid Sans', 'Helvetica Neue',
    sans-serif;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
}
code {
  font-family: source-code-pro, Menlo, Monaco, Consolas, 'Courier New',
    monospace;
}
</file>

<file path="client/src/index.js">
// Entry point for the React application
import React from 'react';
import ReactDOM from 'react-dom/client';
import './index.css';
import App from './App';
const root = ReactDOM.createRoot(document.getElementById('root'));
root.render(
  <React.StrictMode>
    <App />
  </React.StrictMode>
);
</file>

<file path="client/src/minecraft.css">
/* Minecraft-style button */
.minecraft-btn {
  background-color: #727272;
  border: 2px solid #000;
  border-bottom: 4px solid #000;
  image-rendering: pixelated;
  position: relative;
  cursor: pointer;
  transition: all 0.1s;
}
.minecraft-btn:hover {
  background-color: #8b8b8b;
}
.minecraft-btn:active {
  border-bottom: 2px solid #000;
  transform: translateY(2px);
}
/* Minecraft-style container */
.minecraft-box {
  border: 4px solid #000;
  position: relative;
  image-rendering: pixelated;
}
.minecraft-box::before {
  content: '';
  position: absolute;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background: linear-gradient(45deg, 
    transparent 0%,
    transparent 45%,
    rgba(255, 255, 255, 0.1) 45%,
    rgba(255, 255, 255, 0.1) 55%,
    transparent 55%,
    transparent 100%
  );
  background-size: 8px 8px;
}
/* Minecraft dirt texture background */
.dirt-bg {
  background-color: #866043;
  background-image: 
    linear-gradient(45deg, #755539 25%, transparent 25%),
    linear-gradient(-45deg, #755539 25%, transparent 25%),
    linear-gradient(45deg, transparent 75%, #755539 75%),
    linear-gradient(-45deg, transparent 75%, #755539 75%);
  background-size: 4px 4px;
  background-position: 0 0, 0 2px, 2px -2px, -2px 0px;
}
/* Minecraft stone texture background */
.stone-bg {
  background-color: #7a7a7a;
  background-image: 
    linear-gradient(45deg, #686868 25%, transparent 25%),
    linear-gradient(-45deg, #686868 25%, transparent 25%),
    linear-gradient(45deg, transparent 75%, #686868 75%),
    linear-gradient(-45deg, transparent 75%, #686868 75%);
  background-size: 4px 4px;
  background-position: 0 0, 0 2px, 2px -2px, -2px 0px;
}
/* Minecraft grass texture */
.grass-top {
  background-color: #5b9b3f;
  position: relative;
}
.grass-top::after {
  content: '';
  position: absolute;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background-image: 
    linear-gradient(45deg, #4a8033 25%, transparent 25%),
    linear-gradient(-45deg, #4a8033 25%, transparent 25%);
  background-size: 4px 4px;
  opacity: 0.5;
}
/* Pixelated text */
.minecraft-text {
  font-family: 'Press Start 2P', cursive;
  text-shadow: 2px 2px #000;
  letter-spacing: 1px;
}
/* Block breaking animation */
@keyframes blockBreak {
  0% { opacity: 0; }
  50% { opacity: 1; }
  100% { opacity: 0; }
}
.breaking {
  position: relative;
}
.breaking::after {
  content: '';
  position: absolute;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background: 
    linear-gradient(45deg, #000 25%, transparent 25%) -2px 0,
    linear-gradient(-45deg, #000 25%, transparent 25%) 2px 0;
  background-size: 4px 4px;
  animation: blockBreak 1s infinite;
  opacity: 0.3;
}
</file>

<file path="client/package.json">
{
  "name": "minecraft-me-client",
  "version": "0.1.0",
  "private": true,
  "dependencies": {
    "@testing-library/jest-dom": "^5.17.0",
    "@testing-library/react": "^13.4.0",
    "@testing-library/user-event": "^13.5.0",
    "react": "^18.2.0",
    "react-dom": "^18.2.0",
    "react-scripts": "5.0.1",
    "web-vitals": "^2.1.4"
  },
  "scripts": {
    "start": "react-scripts start",
    "build": "react-scripts build",
    "test": "react-scripts test",
    "eject": "react-scripts eject"
  },
  "eslintConfig": {
    "extends": [
      "react-app",
      "react-app/jest"
    ]
  },
  "browserslist": {
    "production": [
      ">0.2%",
      "not dead",
      "not op_mini all"
    ],
    "development": [
      "last 1 chrome version",
      "last 1 firefox version",
      "last 1 safari version"
    ]
  }
}
</file>

<file path="docs/cursor-rules.md">
# Cursor Rules for Minecraft Style Converter

## General Principles
- **Simplicity**: Write minimal, readable code. One job per function, <20 lines max. Clear names (e.g., `convertToMinecraft`).
- **Effectiveness**: Solve the specific problem—no unnecessary features. Reuse libraries/APIs over custom code.
- **Efficiency**: Minimize API calls (e.g., one OpenAI call per conversion). Aim for <10-second user flow. Avoid memory-heavy ops.

## Coding Standards
- **Modularity**: Use small, reusable files (e.g., `openai.js`, `Upload.js`). ES6 imports/exports.
- **Error Handling**: Try/catch for all async ops. Return meaningful errors (e.g., `{ error: "Upload failed" }`).
- **Comments**: One-line comment above each function (e.g., `// Converts photo to Minecraft style`). No inline unless complex.

## Testing Rules
- **Unit Tests**: Every function gets at least one test. Use Jest (backend) and React Testing Library (frontend). Test edge cases.
- **Pipeline Tests**: End-to-end test for critical flows (e.g., upload → payment → download). Mock external APIs.
- **Automation**: Add `test` script in `package.json`. Tests must pass before deployment.

## Workflow
- **Incremental**: Build one feature at a time (e.g., upload, then conversion). Test each individually.
- **Cursor Use**: Prompt with “Follow simplicity, effectiveness, efficiency; include test.” Use “Fix this” for bugs.
- **Deployment**: Always Vercel-ready. No hardcoded secrets—use `.env`.

## Enforcement
- Cursor must apply these rules when generating or editing code.
- If a rule is unclear, default to simplicity and ask for clarification.
</file>

<file path="docs/DevelopmentGuidelines.md">
# Development Guidelines

## Core Rules
- Detailed in `cursor-rules.md`—simplicity, effectiveness, efficiency, testing.
- Cursor must follow these for all code.

## Workflow
- Feature-by-feature build, test each step.
- Deployable to Vercel anytime.

## Milestones
- Week 1: Core functionality.
- Week 2: Polish and deploy.
- April 14, 2025: Live.
</file>

<file path="docs/overview.md">
# Minecraft Style Converter Overview

## Purpose
A web app to upload a photo and convert it to a Minecraft-style character. Targets $1k MRR and leverages the Minecraft movie (April 2025).

## Key Features
- Upload photo (JPG/PNG).
- Convert to Minecraft style via AI.
- Pay via Stripe ($5/5, $10/20, $15/50).
- Download full-res; free preview.

## User Flow
1. Upload photo.
2. See low-res preview.
3. Pay.
4. Download.

## Goals
- MVP live by April 14, 2025.
- Simple, fast, revenue-focused.

## Rules
- See `cursor-rules.md` for coding standards and testing.
</file>

<file path="docs/TechStack.md">
# Tech Stack

## Frontend
- **React**: Single-page app for UI (drag-and-drop upload, result display).
- **CSS**: Minecraft-inspired (pixel fonts, green/brown palette).
- **Tools**: npm, Create React App.

## Backend
- **Node.js**: Runtime for server.
- **Express**: API framework (routes: /upload, /create-checkout).
- **Multer**: File upload handling.
- **OpenAI**: GPT-4o API for image conversion (prompt: "blocky, pixelated Minecraft style").
- **Stripe**: Payment processing (Popcorn Pricing).
- **Sharp**: Image resizing for previews.

## Hosting
- **Vercel**: Deployment for frontend and backend.
- **Domain**: minecraftme.com (TBD).

## Testing
- **Jest**: Backend unit tests.
- **React Testing Library**: Frontend tests.
- **Mocks**: Fake OpenAI/Stripe responses.

## Environment Variables
- `OPENAI_API_KEY`: OpenAI access.
- `STRIPE_SECRET_KEY`: Stripe payments.
- `STRIPE_PUBLISHABLE_KEY`: Frontend Stripe integration.
</file>

<file path="server/__tests__/convert.test.js">
const request = require('supertest');
const app = require('../server');
const { convertToMinecraftStyle } = require('../services/openai');
// Mock OpenAI service
jest.mock('../services/openai');
describe('Convert Endpoint', () => {
  beforeEach(() => {
    jest.clearAllMocks();
  });
  it('successfully converts an image', async () => {
    const mockResponse = {
      url: 'https://example.com/image.png',
      status: 'success'
    };
    convertToMinecraftStyle.mockResolvedValue(mockResponse);
    const response = await request(app)
      .post('/api/convert')
      .send({
        image: 'base64string',
        prompt: 'test prompt',
        size: '1024x1024'
      });
    expect(response.status).toBe(200);
    expect(response.body).toEqual(mockResponse);
  });
  it('validates required fields', async () => {
    const response = await request(app)
      .post('/api/convert')
      .send({
        prompt: 'test prompt'
      });
    expect(response.status).toBe(400);
    expect(response.body.error).toBe('Image is required');
  });
  it('validates image size', async () => {
    // Create a large base64 string
    const largeBase64 = 'a'.repeat(5 * 1024 * 1024);
    const response = await request(app)
      .post('/api/convert')
      .send({
        image: largeBase64,
        prompt: 'test prompt'
      });
    expect(response.status).toBe(400);
    expect(response.body.error).toBe('Image size exceeds maximum allowed size');
  });
  it('validates size parameter', async () => {
    const response = await request(app)
      .post('/api/convert')
      .send({
        image: 'base64string',
        prompt: 'test prompt',
        size: 'invalid'
      });
    expect(response.status).toBe(400);
    expect(response.body.error).toBe('Invalid size parameter');
  });
  it('handles OpenAI service errors', async () => {
    convertToMinecraftStyle.mockRejectedValue(new Error('OpenAI Error'));
    const response = await request(app)
      .post('/api/convert')
      .send({
        image: 'base64string',
        prompt: 'test prompt'
      });
    expect(response.status).toBe(500);
    expect(response.body.error).toContain('OpenAI Error');
  });
});
</file>

<file path="server/__tests__/openai.test.js">
const { convertToMinecraftStyle } = require('../services/openai');
// Mock OpenAI
jest.mock('openai', () => {
  return jest.fn().mockImplementation(() => ({
    images: {
      create: jest.fn()
    }
  }));
});
describe('OpenAI Service', () => {
  let openai;
  beforeEach(() => {
    // Clear all mocks
    jest.clearAllMocks();
    // Get instance of mocked OpenAI
    openai = require('openai');
  });
  it('successfully converts an image', async () => {
    const mockResponse = {
      data: [{ url: 'https://example.com/image.png' }]
    };
    openai.mockImplementation(() => ({
      images: {
        create: jest.fn().mockResolvedValue(mockResponse)
      }
    }));
    const result = await convertToMinecraftStyle('base64image', 'test prompt');
    expect(result).toEqual({
      url: 'https://example.com/image.png',
      status: 'success'
    });
  });
  it('retries on rate limit error', async () => {
    const mockError = new Error('Rate limit exceeded');
    mockError.status = 429;
    const mockSuccess = {
      data: [{ url: 'https://example.com/image.png' }]
    };
    const mockOpenAI = {
      images: {
        create: jest.fn()
          .mockRejectedValueOnce(mockError)
          .mockResolvedValueOnce(mockSuccess)
      }
    };
    openai.mockImplementation(() => mockOpenAI);
    const result = await convertToMinecraftStyle('base64image', 'test prompt');
    expect(mockOpenAI.images.create).toHaveBeenCalledTimes(2);
    expect(result).toEqual({
      url: 'https://example.com/image.png',
      status: 'success'
    });
  });
  it('fails after max retries', async () => {
    const mockError = new Error('Rate limit exceeded');
    mockError.status = 429;
    const mockOpenAI = {
      images: {
        create: jest.fn().mockRejectedValue(mockError)
      }
    };
    openai.mockImplementation(() => mockOpenAI);
    await expect(convertToMinecraftStyle('base64image', 'test prompt'))
      .rejects
      .toThrow('Failed to convert image after 3 attempts');
  });
  it('does not retry on client errors', async () => {
    const mockError = new Error('Invalid input');
    mockError.status = 400;
    const mockOpenAI = {
      images: {
        create: jest.fn().mockRejectedValue(mockError)
      }
    };
    openai.mockImplementation(() => mockOpenAI);
    await expect(convertToMinecraftStyle('base64image', 'test prompt'))
      .rejects
      .toThrow('Failed to convert image after 1 attempts');
    expect(mockOpenAI.images.create).toHaveBeenCalledTimes(1);
  });
});
</file>

<file path="server/middleware/validation.js">
const { createError } = require('../utils/errors');
/**
 * Validates the request body for image conversion
 */
function validateConversionRequest(req, res, next) {
  try {
    const { image, prompt, size } = req.body;
    // Check if required fields are present
    if (!image) {
      throw createError('Image is required', 400);
    }
    if (!prompt) {
      throw createError('Prompt is required', 400);
    }
    // Validate image base64 string
    if (!isValidBase64(image)) {
      throw createError('Invalid base64 image format', 400);
    }
    // Validate image size
    const sizeInBytes = Buffer.from(image, 'base64').length;
    if (sizeInBytes > parseInt(process.env.MAX_FILE_SIZE)) {
      throw createError('Image size exceeds maximum allowed size', 400);
    }
    // Validate size parameter if provided
    if (size && !['256x256', '512x512', '1024x1024'].includes(size)) {
      throw createError('Invalid size parameter', 400);
    }
    next();
  } catch (error) {
    next(error);
  }
}
/**
 * Checks if a string is valid base64
 */
function isValidBase64(str) {
  try {
    return Buffer.from(str, 'base64').toString('base64') === str;
  } catch {
    return false;
  }
}
module.exports = {
  validateConversionRequest
};
</file>

<file path="server/routes/convert.js">
const express = require('express');
const router = express.Router();
const { convertToMinecraftStyle } = require('../services/openai');
const { validateConversionRequest } = require('../middleware/validation');
const { createError } = require('../utils/errors');
/**
 * POST /api/convert
 * Converts an image to Minecraft style using OpenAI
 */
router.post('/', validateConversionRequest, async (req, res, next) => {
  try {
    console.log('Received conversion request');
    const { image, prompt, size } = req.body;
    console.log('Request details:', {
      promptLength: prompt?.length,
      imageDataLength: image?.length,
      size
    });
    console.log('Starting image conversion...');
    const result = await convertToMinecraftStyle(image, prompt, size);
    console.log('Conversion successful, sending response:', {
      status: result.status,
      hasUrl: !!result.url,
      url: result.url ? result.url.substring(0, 50) + '...' : null
    });
    res.header('Access-Control-Allow-Origin', '*');
    res.header('Access-Control-Allow-Methods', 'POST');
    res.header('Access-Control-Allow-Headers', 'Content-Type');
    res.json({
      success: true,
      ...result
    });
  } catch (error) {
    console.error('Conversion error details:', {
      message: error.message,
      stack: error.stack,
      status: error.status
    });
    next(error);
  }
});
module.exports = router;
</file>

<file path="server/routes/test.js">
const express = require('express');
const router = express.Router();
const { testMinimalImage } = require('../services/openai');
router.get('/test-image', async (req, res) => {
  try {
    console.log('=== Running Minimal Image Test ===');
    const result = await testMinimalImage();
    res.json({ success: true, result });
  } catch (error) {
    console.error('Test failed:', error);
    res.status(500).json({ 
      success: false, 
      error: error.message,
      status: error.status || 'unknown'
    });
  }
});
module.exports = router;
</file>

<file path="server/services/openai.js">
const sharp = require('sharp');
const { createError } = require('../utils/errors');
const axios = require('axios');
/**
 * Compress and resize image to meet OpenAI's requirements
 */
async function prepareImage(base64Image) {
  try {
    const buffer = Buffer.from(base64Image, 'base64');
    console.log('Original buffer size:', buffer.length);
    const metadata = await sharp(buffer).metadata();
    console.log('Image metadata:', {
      format: metadata.format,
      width: metadata.width,
      height: metadata.height,
      size: buffer.length
    });
    const processedBuffer = await sharp(buffer)
      .resize(512, 512, { // 512x512 for better detail
        fit: 'cover',
        position: 'center'
      })
      .png()
      .toBuffer();
    const processedMetadata = await sharp(processedBuffer).metadata();
    console.log('Processed image:', {
      format: processedMetadata.format,
      width: processedMetadata.width,
      height: processedMetadata.height,
      size: processedBuffer.length,
      channels: processedMetadata.channels
    });
    if (processedBuffer.length > 4 * 1024 * 1024) {
      throw new Error('Processed image exceeds 4MB limit for OpenAI API');
    }
    return processedBuffer;
  } catch (error) {
    console.error('Image preparation failed:', error);
    throw createError('Failed to prepare image: ' + error.message, 500);
  }
}
/**
 * Converts an image to Minecraft style using OpenAI's vision and generation APIs
 */
async function convertToMinecraftStyle(base64Image, prompt, size = '1024x1024') {
  const startTime = Date.now();
  try {
    console.log('=== Enhanced Image Conversion Process ===');
    console.log(`[${Date.now() - startTime}ms] 1. Processing image...`);
    const processedImage = await prepareImage(base64Image);
    console.log(`[${Date.now() - startTime}ms] 2. Image processed, size: ${processedImage.length} bytes`);
    const base64Processed = processedImage.toString('base64');
    console.log(`[${Date.now() - startTime}ms] 3. Sending to OpenAI Vision API for description...`);
    // Step 1: Use vision API to describe the image in Minecraft style
    const visionResponse = await axios.post('https://api.openai.com/v1/chat/completions', {
      model: 'gpt-4o',
      messages: [
        {
          role: 'user',
          content: [
            {
              type: 'text',
              text: prompt || 'Provide a concise description of the main subject in this image as a Minecraft character with blocky, pixelated features, cubic limbs, and a simplified color palette. Include specific details about their appearance, clothing, accessories, and any objects they are holding or interacting with. Do not provide instructions or steps.'
            },
            {
              type: 'image_url',
              image_url: { url: `data:image/png;base64,${base64Processed}` }
            }
          ]
        }
      ],
      max_tokens: 150, // Reduced to ensure a concise description
    }, {
      headers: {
        Authorization: `Bearer ${process.env.OPENAI_API_KEY}`,
        'Content-Type': 'application/json'
      },
      timeout: 60000,
    });
    let description = visionResponse.data.choices[0].message.content;
    console.log(`[${Date.now() - startTime}ms] 4. Vision API description received:`, description);
    // Truncate the description to ensure the total prompt length is under 1000 characters
    const prefix = "A Minecraft character based on this description: ";
    const maxDescriptionLength = 1000 - prefix.length; // Leave room for the prefix
    if (description.length > maxDescriptionLength) {
      description = description.substring(0, maxDescriptionLength);
      console.log(`[${Date.now() - startTime}ms] Description truncated to ${description.length} characters`);
    }
    // Step 2: Use image generation API to create the Minecraft-style image
    console.log(`[${Date.now() - startTime}ms] 5. Sending description to OpenAI Image Generation API...`);
    const generationResponse = await axios.post('https://api.openai.com/v1/images/generations', {
      prompt: `${prefix}${description}`,
      n: 1,
      size: size,
    }, {
      headers: {
        Authorization: `Bearer ${process.env.OPENAI_API_KEY}`,
        'Content-Type': 'application/json'
      },
      timeout: 60000,
    });
    console.log(`[${Date.now() - startTime}ms] 6. Image generation API response received`);
    return {
      url: generationResponse.data.data[0].url,
      status: 'success',
      timing: { total: Date.now() - startTime, unit: 'ms' }
    };
  } catch (error) {
    console.error(`[${Date.now() - startTime}ms] Error during calling OpenAI API:`, error);
    throw createError(
      `Failed during calling OpenAI API: ${error.response?.status} ${error.response?.data?.error?.message || error.message}`,
      error.response?.status || 500
    );
  }
}
module.exports = {
  convertToMinecraftStyle
};
</file>

<file path="server/utils/errors.js">
/**
 * Creates a custom error with status code
 */
function createError(message, statusCode = 500) {
  const error = new Error(message);
  // Handle case where statusCode might be an object (e.g., { statusCode: 400 })
  error.status = typeof statusCode === 'object' ? statusCode.statusCode || 500 : statusCode;
  return error;
}
/**
 * Error handler middleware
 */
function errorHandler(err, req, res, next) {
  console.error('=== Error Details ===', err);
  const statusCode = err.status || 500;
  const message = err.message || 'Internal Server Error';
  const timing = err.timing || undefined;
  res.status(statusCode).json({
    error: message,
    code: statusCode,
    ...(timing && { timing }),
    ...(process.env.NODE_ENV === 'development' && { stack: err.stack })
  });
}
module.exports = {
  createError,
  errorHandler
};
</file>

<file path="server/package.json">
{
  "name": "minecraftme-server",
  "version": "1.0.0",
  "description": "Backend server for MinecraftMe image conversion",
  "main": "server.js",
  "scripts": {
    "start": "node server.js",
    "dev": "nodemon server.js",
    "test": "jest"
  },
  "dependencies": {
    "axios": "^1.8.4",
    "cors": "^2.8.5",
    "dotenv": "^16.4.7",
    "express": "^4.18.2",
    "express-rate-limit": "^7.1.5",
    "openai": "^4.24.1",
    "sharp": "^0.33.5"
  },
  "devDependencies": {
    "jest": "^29.7.0",
    "nodemon": "^3.0.2",
    "supertest": "^6.3.3"
  }
}
</file>

<file path="server/server.js">
require('dotenv').config();
const express = require('express');
const cors = require('cors');
const rateLimit = require('express-rate-limit');
const { errorHandler } = require('./utils/errors');
const convertRouter = require('./routes/convert');
const app = express();
// Debug logging
console.log('Starting server with configuration:');
console.log('PORT:', process.env.PORT);
console.log('NODE_ENV:', process.env.NODE_ENV);
// Configure rate limiting
const limiter = rateLimit({
  windowMs: parseInt(process.env.RATE_LIMIT_WINDOW_MS) || 900000, // 15 minutes
  max: parseInt(process.env.RATE_LIMIT_MAX_REQUESTS) || 50 // limit each IP to 50 requests per windowMs
});
// Middleware
app.use(cors());
app.use(express.json({ limit: '5mb' }));
app.use(limiter);
// Route debugging middleware
app.use((req, res, next) => {
  console.log(`${new Date().toISOString()} - ${req.method} ${req.path}`);
  console.log('Request headers:', req.headers);
  next();
});
// Routes
app.use('/api/convert', convertRouter);
// Add a test route
app.get('/api/test', (req, res) => {
  res.json({ status: 'Server is running' });
});
// Error handling
app.use(errorHandler);
// Start server
const PORT = process.env.PORT || 3001;
app.listen(PORT, () => {
  console.log(`Server running on port ${PORT}`);
  console.log('Available routes:');
  console.log('- POST /api/convert');
  console.log('- GET /api/test');
});
module.exports = app; // For testing
</file>

<file path="server/test-direct-api.js">
// Load environment variables
require('dotenv').config();
const { testMinimalImage } = require('./services/openai');
async function runTest() {
  console.log('Starting minimal image test with direct API call...');
  try {
    const result = await testMinimalImage();
    console.log('Test successful!', result);
  } catch (error) {
    console.error('Test failed:', error.message);
  }
}
runTest();
</file>

<file path="server/test-image-upload.js">
const { testMinimalImage, convertToMinecraftStyle } = require('./services/openai');
async function runTests() {
  console.log('=== Starting Image Upload Tests ===\n');
  try {
    console.log('Test 1: Minimal Image Test');
    console.log('----------------------------');
    const minimalResult = await testMinimalImage();
    console.log('Minimal image test result:', minimalResult);
  } catch (error) {
    console.error('Minimal image test failed:', error);
  }
  console.log('\n=== Tests Complete ===');
}
runTests();
</file>

<file path="server/test-openai.js">
// Load environment variables
require('dotenv').config();
const { testMinimalImage, convertToMinecraftStyle } = require('./services/openai');
const fs = require('fs');
const path = require('path');
// Check if API key is loaded and log status (without revealing the key)
console.log('OpenAI API Key loaded:', !!process.env.OPENAI_API_KEY);
async function runTests() {
  try {
    console.log('\n=== Test 1: Minimal Image ===');
    const minimalResult = await testMinimalImage();
    console.log('Minimal image test successful!', minimalResult);
    // If minimal test succeeds, we can try with a real image file
    console.log('\n=== Test 2: Your Uploaded Image ===');
    // Note: You would need to provide the path to your image file
    // const imagePath = path.join(__dirname, 'your-test-image.jpg');
    // if (fs.existsSync(imagePath)) {
    //   const imageBase64 = fs.readFileSync(imagePath).toString('base64');
    //   const result = await convertToMinecraftStyle(imageBase64);
    //   console.log('Regular image test successful!', result);
    // } else {
    //   console.log('Test image not found, skipping Test 2');
    // }
  } catch (error) {
    console.error('Test failed:', error.message);
    if (error.timing) {
      console.error('Error occurred after:', error.timing.total, 'ms');
    }
  }
}
if (process.env.OPENAI_API_KEY) {
  runTests();
} else {
  console.error('ERROR: OPENAI_API_KEY environment variable is missing. Please set it before running tests.');
  console.log('You can set it temporarily by running:');
  console.log('  OPENAI_API_KEY=your_api_key node test-openai.js');
}
</file>

<file path="package.json">
{
  "dependencies": {
    "dotenv": "^16.4.7"
  }
}
</file>

<file path="test-image-upload.js">
const { testMinimalImage } = require('./server/services/openai');
async function runTests() {
  console.log('=== Starting Image Upload Tests ===\n');
  try {
    console.log('Test 1: Minimal Image Test');
    console.log('----------------------------');
    const minimalResult = await testMinimalImage();
    console.log('Minimal image test result:', minimalResult);
  } catch (error) {
    console.error('Minimal image test failed:', error.message);
    if (error.response) {
      console.error('Status:', error.response.status);
    }
  }
  console.log('\n=== Tests Complete ===');
}
runTests();
</file>

</files>
